diff --git a/game/Engine.ts b/game/Engine.ts
index c816fde..a78cdbd 100644
--- a/game/Engine.ts
+++ b/game/Engine.ts
@@ -1,4 +1,4 @@
-import { GameState, ObstacleInstance, ObstacleType, TrickType, SkinDefinition } from "./types";
+import { GameState, CrashState, ObstacleInstance, ObstacleType, TrickType, SkinDefinition } from "./types";
 import {
   GROUND_RATIO,
   INITIAL_SPEED,
@@ -8,6 +8,10 @@ import {
   MAX_SPEED_MULTIPLIER,
   FLIP_TOLERANCE,
   SKETCHY_TOLERANCE,
+  CRASH_DURATION,
+  CRASH_GRAVITY,
+  CRASH_BOUNCE_DAMPING,
+  CRASH_SHAKE_INITIAL,
 } from "./constants";
 import {
   FloatingText,
@@ -22,7 +26,7 @@ import {
 } from "./TrickSystem";
 import { createPlayer, updatePlayer, jumpPlayer, startBackflip, startFrontflip, startSuperman, startNoHander } from "./Player";
 import { createBackgroundLayers, updateLayers } from "./Background";
-import { drawBackground, drawPlayer, drawObstacle, drawFloatingText } from "./rendering";
+import { drawBackground, drawPlayer, drawObstacle, drawFloatingText, drawCrashBike, drawCrashRider } from "./rendering";
 import { spawnObstacle, createObstacle, nextSpawnGap } from "./Obstacle";
 import { checkCollision, checkRideableCollision } from "./Collision";
 import { processRampInteractions, processRidingState } from "./RampPhysics";
@@ -66,6 +70,15 @@ export class Engine {
   private debugSequence: ObstacleType[] | null = null;
   private debugIndex: number = 0;
   private debugGap: number = 500;
+  private crashState: CrashState = {
+    elapsed: 0, duration: CRASH_DURATION,
+    shakeIntensity: 0, shakeOffsetX: 0, shakeOffsetY: 0,
+    riderX: 0, riderY: 0, riderVX: 0, riderVY: 0,
+    riderAngle: 0, riderAngularVel: 0, riderBounceCount: 0,
+    bikeX: 0, bikeY: 0, bikeVX: 0, bikeVY: 0,
+    bikeAngle: 0, bikeAngularVel: 0, bikeBounceCount: 0,
+    bikeWheelRotation: 0,
+  };
 
   constructor(canvas: HTMLCanvasElement, callbacks: EngineCallbacks) {
     this.canvas = canvas;
@@ -162,6 +175,8 @@ export class Engine {
 
     if (this.state === GameState.RUNNING) {
       this.update(dt, rawDt);
+    } else if (this.state === GameState.CRASHING) {
+      this.updateCrash(dt, rawDt);
     }
 
     this.render();
@@ -260,7 +275,7 @@ export class Engine {
       if (obs.rideable) {
         const result = checkRideableCollision(this.player, obs);
         if (result === "crash") {
-          this.gameOver();
+          this.startCrash();
           return;
         }
         if (result === "land_on_top") {
@@ -282,26 +297,135 @@ export class Engine {
         }
       } else {
         if (checkCollision(this.player, obs)) {
-          this.gameOver();
+          this.startCrash();
           return;
         }
       }
     }
   }
 
-  private gameOver(): void {
-    this.state = GameState.GAME_OVER;
+  private startCrash(): void {
+    this.state = GameState.CRASHING;
     this.sound.stopMusic();
     this.sound.playCrash();
+    this.initCrashState();
+    this.callbacks.onStateChange(this.state);
+  }
+
+  private gameOver(): void {
+    this.state = GameState.GAME_OVER;
     this.callbacks.onStateChange(this.state);
     this.callbacks.onGameOver(this.score);
   }
 
+  private initCrashState(): void {
+    const cs = this.crashState;
+    const p = this.player;
+    const speedFactor = this.speed / INITIAL_SPEED;
+
+    cs.elapsed = 0;
+    cs.duration = CRASH_DURATION;
+    cs.shakeIntensity = CRASH_SHAKE_INITIAL;
+    cs.shakeOffsetX = 0;
+    cs.shakeOffsetY = 0;
+
+    // Rider: ejected forward and upward
+    cs.riderX = p.x + 10;
+    cs.riderY = p.y - 5;
+    cs.riderVX = this.speed * 0.6 + 1.5;
+    cs.riderVY = -6 - speedFactor * 2;
+    cs.riderAngle = 0;
+    cs.riderAngularVel = 0.15 + speedFactor * 0.08;
+    cs.riderBounceCount = 0;
+
+    // Carry upward momentum if player was still rising
+    if (p.velocityY < 0) {
+      cs.riderVY += p.velocityY * 0.5;
+    }
+
+    // Bike: slides forward, slight upward kick
+    cs.bikeX = p.x;
+    cs.bikeY = p.y + p.height * 0.3;
+    cs.bikeVX = this.speed * 0.3;
+    cs.bikeVY = -2;
+    cs.bikeAngle = 0;
+    cs.bikeAngularVel = -0.08;
+    cs.bikeBounceCount = 0;
+    cs.bikeWheelRotation = p.wheelRotation;
+  }
+
+  private updateCrash(dt: number, rawDt: number): void {
+    const cs = this.crashState;
+    cs.elapsed += rawDt / 1000;
+
+    if (cs.elapsed >= cs.duration) {
+      this.gameOver();
+      return;
+    }
+
+    const groundY = this.groundY;
+    const friction = 0.95;
+    const angularDamping = 0.7;
+
+    // Screen shake — exponential decay
+    cs.shakeIntensity *= 1 - 0.06 * dt;
+    if (cs.shakeIntensity < 0.3) cs.shakeIntensity = 0;
+    cs.shakeOffsetX = (Math.random() - 0.5) * 2 * cs.shakeIntensity;
+    cs.shakeOffsetY = (Math.random() - 0.5) * 2 * cs.shakeIntensity;
+
+    // Rider physics
+    const riderGroundY = groundY - 15;
+    const riderSettled = cs.riderBounceCount >= 2;
+    if (!riderSettled) cs.riderVY += CRASH_GRAVITY * dt;
+    cs.riderX += cs.riderVX * dt;
+    if (!riderSettled) cs.riderY += cs.riderVY * dt;
+    cs.riderAngle += cs.riderAngularVel * dt;
+    cs.riderVX *= friction;
+
+    if (cs.riderY >= riderGroundY && cs.riderVY > 0 && !riderSettled) {
+      cs.riderY = riderGroundY;
+      cs.riderBounceCount++;
+      if (cs.riderBounceCount >= 2) {
+        cs.riderVY = 0;
+        cs.riderAngularVel = 0;
+      } else {
+        cs.riderVY = -cs.riderVY * CRASH_BOUNCE_DAMPING;
+        cs.riderAngularVel *= angularDamping;
+      }
+      cs.riderVX *= 0.7;
+    }
+
+    // Bike physics
+    const bikeGroundY = groundY - 12;
+    const bikeSettled = cs.bikeBounceCount >= 2;
+    if (!bikeSettled) cs.bikeVY += CRASH_GRAVITY * dt;
+    cs.bikeX += cs.bikeVX * dt;
+    if (!bikeSettled) cs.bikeY += cs.bikeVY * dt;
+    cs.bikeAngle += cs.bikeAngularVel * dt;
+    cs.bikeVX *= friction;
+
+    if (cs.bikeY >= bikeGroundY && cs.bikeVY > 0 && !bikeSettled) {
+      cs.bikeY = bikeGroundY;
+      cs.bikeBounceCount++;
+      if (cs.bikeBounceCount >= 2) {
+        cs.bikeVY = 0;
+        cs.bikeAngularVel = 0;
+      } else {
+        cs.bikeVY = -cs.bikeVY * CRASH_BOUNCE_DAMPING;
+        cs.bikeAngularVel *= angularDamping;
+      }
+      cs.bikeVX *= 0.6;
+    }
+
+    // Decelerating wheel spin
+    cs.bikeWheelRotation += cs.bikeVX * dt * 0.08;
+  }
+
   /** Handle flip landing. Returns true if game over (crash). */
   private handleFlipLanding(angle: number, direction: number, fullFlip: number, tolerance: number, sketchyTolerance: number): boolean {
     const result = evaluateFlipLanding(angle, direction, fullFlip, tolerance, sketchyTolerance);
     resetFlipState(this.player);
-    if (result.crashed) { this.gameOver(); return true; }
+    if (result.crashed) { this.startCrash(); return true; }
     this.awardTrickBonus(result.label!, result.bonus!, result.sketchy);
     return false;
   }
@@ -310,7 +434,7 @@ export class Engine {
   private handlePoseTrickLanding(): boolean {
     const result = evaluatePoseTrickLanding(this.player);
     resetPoseState(this.player);
-    if (result.crashed) { this.gameOver(); return true; }
+    if (result.crashed) { this.startCrash(); return true; }
     this.awardTrickBonus(result.label!, result.bonus!, result.sketchy);
     return false;
   }
@@ -319,7 +443,7 @@ export class Engine {
   private handleComboLanding(angle: number, direction: number, fullFlip: number, tolerance: number, sketchyTolerance: number): boolean {
     const result = evaluateComboLanding(this.player, angle, direction, fullFlip, tolerance, sketchyTolerance);
     resetAllTrickState(this.player);
-    if (result.crashed) { this.gameOver(); return true; }
+    if (result.crashed) { this.startCrash(); return true; }
     this.awardTrickBonus(result.label!, result.bonus!, result.sketchy);
     return false;
   }
@@ -338,14 +462,32 @@ export class Engine {
     const palette = this.envManager.getCurrentPalette();
     const drawers = this.envManager.getBackgroundDrawers();
     ctx.clearRect(0, 0, canvasW, canvasH);
+
+    const crashing = this.state === GameState.CRASHING;
+    if (crashing) {
+      ctx.save();
+      ctx.translate(this.crashState.shakeOffsetX, this.crashState.shakeOffsetY);
+    }
+
     drawBackground(ctx, this.layers, canvasW, canvasH, groundY, palette, drawers);
     for (const obs of this.obstacles) {
       drawObstacle(ctx, obs, palette);
     }
-    drawPlayer(ctx, this.player, this.skin);
+
+    if (crashing) {
+      drawCrashBike(ctx, this.crashState, this.skin);
+      drawCrashRider(ctx, this.crashState, this.skin);
+    } else {
+      drawPlayer(ctx, this.player, this.skin);
+    }
+
     for (const ft of this.floatingTexts) {
       drawFloatingText(ctx, ft.text, ft.x, ft.y, ft.opacity, ft.color);
     }
+
+    if (crashing) {
+      ctx.restore();
+    }
   }
 
   getScore(): number {
diff --git a/game/constants.ts b/game/constants.ts
index bbd6733..e1b4052 100644
--- a/game/constants.ts
+++ b/game/constants.ts
@@ -29,6 +29,12 @@ export const DOUBLE_CHAIN_BONUS = 100;
 export const TRIPLE_CHAIN_BONUS = 200;
 export const COMBO_MULTIPLIER = 2;
 
+// Crash animation
+export const CRASH_DURATION = 1.2; // seconds
+export const CRASH_GRAVITY = 0.45;
+export const CRASH_BOUNCE_DAMPING = 0.35;
+export const CRASH_SHAKE_INITIAL = 8; // pixels
+
 // Player dimensions
 export const PLAYER_X_RATIO = 0.20; // 20% from the left of the canvas
 export const PLAYER_WIDTH = 64;
diff --git a/game/rendering/CrashRenderer.ts b/game/rendering/CrashRenderer.ts
new file mode 100644
index 0000000..eaffd30
--- /dev/null
+++ b/game/rendering/CrashRenderer.ts
@@ -0,0 +1,147 @@
+import { CrashState, SkinDefinition } from "../types";
+import {
+  getBikeGeometry,
+  getWheelParams,
+  drawWheel,
+  drawBikeFrame,
+  drawHandlebars,
+  drawHelmet,
+} from "./PlayerRenderer";
+import { PLAYER_WIDTH, PLAYER_HEIGHT } from "../constants";
+
+export function drawCrashBike(
+  ctx: CanvasRenderingContext2D,
+  crash: CrashState,
+  skin: SkinDefinition
+): void {
+  const c = skin.colors;
+  const glowWheels = skin.bikeStyle === "fixie";
+
+  // Fade-out in last 0.3s
+  const fadeStart = crash.duration - 0.3;
+  const alpha =
+    crash.elapsed > fadeStart
+      ? 1 - (crash.elapsed - fadeStart) / 0.3
+      : 1;
+
+  ctx.save();
+  ctx.globalAlpha = Math.max(0, alpha);
+
+  // Position and rotate the bike around its center
+  ctx.translate(crash.bikeX, crash.bikeY);
+  ctx.rotate(crash.bikeAngle);
+
+  // Draw bike centered at origin
+  const localX = -PLAYER_WIDTH / 2;
+  const localY = -PLAYER_HEIGHT / 2;
+  const g = getBikeGeometry(skin.bikeStyle, localX, localY);
+  const { spokeCount, spokeWidth, spokeColor, knobby } = getWheelParams(skin);
+
+  drawWheel(
+    ctx, g.rearWheelX, g.wheelY, g.wheelR, crash.bikeWheelRotation,
+    c.wheel, glowWheels, spokeCount, spokeWidth, spokeColor, knobby
+  );
+  drawWheel(
+    ctx, g.frontWheelX, g.wheelY, g.wheelR, crash.bikeWheelRotation,
+    c.wheel, glowWheels, spokeCount, spokeWidth, spokeColor, knobby
+  );
+  drawBikeFrame(ctx, skin, g, localX, localY);
+  drawHandlebars(ctx, skin, g);
+
+  ctx.restore();
+}
+
+export function drawCrashRider(
+  ctx: CanvasRenderingContext2D,
+  crash: CrashState,
+  skin: SkinDefinition
+): void {
+  const c = skin.colors;
+
+  // Fade-out in last 0.3s
+  const fadeStart = crash.duration - 0.3;
+  const alpha =
+    crash.elapsed > fadeStart
+      ? 1 - (crash.elapsed - fadeStart) / 0.3
+      : 1;
+
+  ctx.save();
+  ctx.globalAlpha = Math.max(0, alpha);
+
+  ctx.translate(crash.riderX, crash.riderY);
+  ctx.rotate(crash.riderAngle);
+
+  // Limb spread: compact → ragdoll over first 0.3s
+  const spread = Math.min(crash.elapsed / 0.3, 1);
+
+  // Proportions centered at hip (0,0)
+  const hipX = 0, hipY = 0;
+  const shoulderX = 2, shoulderY = -13;
+  const headX = shoulderX + 1, headY = shoulderY - 7;
+
+  // Legs — spread outward
+  ctx.strokeStyle = c.pants;
+  ctx.lineWidth = 3;
+  ctx.beginPath();
+  ctx.moveTo(hipX - 1, hipY + 2);
+  ctx.lineTo(hipX - 6 * spread, hipY + 12);
+  ctx.stroke();
+  ctx.beginPath();
+  ctx.moveTo(hipX + 2, hipY + 2);
+  ctx.lineTo(hipX + 8 * spread, hipY + 10);
+  ctx.stroke();
+
+  // Torso
+  ctx.strokeStyle = c.shirt;
+  ctx.lineWidth = 3.5;
+  ctx.beginPath();
+  ctx.moveTo(hipX, hipY);
+  ctx.lineTo(shoulderX, shoulderY);
+  ctx.stroke();
+
+  // Arms — flung outward
+  ctx.strokeStyle = c.shirt;
+  ctx.lineWidth = 2.5;
+  ctx.beginPath();
+  ctx.moveTo(shoulderX, shoulderY);
+  ctx.lineTo(shoulderX - 10 * spread, shoulderY + 3);
+  ctx.stroke();
+  ctx.beginPath();
+  ctx.moveTo(shoulderX, shoulderY);
+  ctx.lineTo(shoulderX + 8 * spread, shoulderY - 5 * spread);
+  ctx.stroke();
+
+  // Hands
+  ctx.fillStyle = c.skin;
+  ctx.beginPath();
+  ctx.arc(shoulderX - 10 * spread, shoulderY + 3, 2, 0, Math.PI * 2);
+  ctx.fill();
+  ctx.beginPath();
+  ctx.arc(shoulderX + 8 * spread, shoulderY - 5 * spread, 2, 0, Math.PI * 2);
+  ctx.fill();
+
+  // Head
+  ctx.fillStyle = c.skin;
+  ctx.beginPath();
+  ctx.ellipse(headX, headY + 1, 5, 6, 0, 0, Math.PI * 2);
+  ctx.fill();
+
+  // Eye
+  ctx.fillStyle = "#2e2e2e";
+  ctx.beginPath();
+  ctx.arc(headX + 3, headY, 1.2, 0, Math.PI * 2);
+  ctx.fill();
+
+  // Sunglasses for Shadow Ops
+  if (skin.bikeStyle === "fatTire") {
+    ctx.fillStyle = "#1a1a1a";
+    ctx.fillRect(headX - 5, headY - 1.5, 11, 3);
+    ctx.fillStyle = "rgba(255,255,255,0.3)";
+    ctx.fillRect(headX + 3, headY - 1, 2, 1);
+  }
+
+  // Helmet
+  drawHelmet(ctx, headX, headY, skin.helmetStyle, c.helmet);
+
+  ctx.restore();
+}
diff --git a/game/rendering/PlayerRenderer.ts b/game/rendering/PlayerRenderer.ts
index 31732a3..e3d666c 100644
--- a/game/rendering/PlayerRenderer.ts
+++ b/game/rendering/PlayerRenderer.ts
@@ -10,7 +10,7 @@ function lerp(a: number, b: number, t: number): number {
 
 // --- Helmet styles (skin-specific headwear) ---
 
-function drawHelmet(
+export function drawHelmet(
   ctx: CanvasRenderingContext2D,
   headX: number,
   headY: number,
@@ -97,7 +97,7 @@ function drawHelmet(
 
 // --- Bike geometry per style ---
 
-interface BikeGeom {
+export interface BikeGeom {
   wheelR: number;
   rearWheelX: number;
   frontWheelX: number;
@@ -112,7 +112,7 @@ interface BikeGeom {
   headY: number;
 }
 
-function getBikeGeometry(bikeStyle: BikeStyle, x: number, y: number): BikeGeom {
+export function getBikeGeometry(bikeStyle: BikeStyle, x: number, y: number): BikeGeom {
   switch (bikeStyle) {
     case "racing":
       // Road bike: shorter wheelbase, taller frame
@@ -143,7 +143,7 @@ function getBikeGeometry(bikeStyle: BikeStyle, x: number, y: number): BikeGeom {
   }
 }
 
-function drawWheel(
+export function drawWheel(
   ctx: CanvasRenderingContext2D,
   cx: number,
   cy: number,
@@ -206,7 +206,7 @@ function drawWheel(
   }
 }
 
-function drawBikeFrame(
+export function drawBikeFrame(
   ctx: CanvasRenderingContext2D,
   skin: SkinDefinition,
   g: BikeGeom,
@@ -285,7 +285,7 @@ function drawBikeFrame(
   ctx.fillRect(pedalRX - 3, pedalY - 1, 6, 3);
 }
 
-function drawHandlebars(
+export function drawHandlebars(
   ctx: CanvasRenderingContext2D,
   skin: SkinDefinition,
   g: BikeGeom
@@ -351,6 +351,19 @@ function drawHandlebars(
   return { gripX: stemTopX - 2, gripY: stemTopY };
 }
 
+export function getWheelParams(skin: SkinDefinition): {
+  spokeCount: number; spokeWidth: number; spokeColor?: string; knobby: boolean;
+} {
+  let spokeCount = 6, spokeWidth = 1.2, spokeColor: string | undefined, knobby = false;
+  switch (skin.bikeStyle) {
+    case "racing":  spokeCount = 5; break;
+    case "mtb":     knobby = true; break;
+    case "cruiser": spokeCount = 3; spokeWidth = 3.6; spokeColor = skin.colors.frame; break;
+    case "fatTire": spokeCount = 8; spokeColor = "#aaaaaa"; break;
+  }
+  return { spokeCount, spokeWidth, spokeColor, knobby };
+}
+
 export function drawPlayer(ctx: CanvasRenderingContext2D, player: PlayerState, skin: SkinDefinition) {
   const { x, y, wheelRotation, bikeTilt, riderLean, riderCrouch, legTuck, backflipAngle, flipDirection } = player;
   const c = skin.colors;
@@ -382,16 +395,7 @@ export function drawPlayer(ctx: CanvasRenderingContext2D, player: PlayerState, s
   ctx.translate(-g.pivotX, -g.pivotY);
 
   // ── Wheels ──
-  let spokeCount = 6;
-  let spokeWidth = 1.2;
-  let spokeColor: string | undefined;
-  let knobby = false;
-  switch (skin.bikeStyle) {
-    case "racing":  spokeCount = 5; break;
-    case "mtb":     knobby = true; break;
-    case "cruiser": spokeCount = 3; spokeWidth = 3.6; spokeColor = c.frame; break;
-    case "fatTire": spokeCount = 8; spokeColor = "#aaaaaa"; break;
-  }
+  const { spokeCount, spokeWidth, spokeColor, knobby } = getWheelParams(skin);
   drawWheel(ctx, g.rearWheelX, g.wheelY, g.wheelR, wheelRotation, c.wheel, glowWheels, spokeCount, spokeWidth, spokeColor, knobby);
   drawWheel(ctx, g.frontWheelX, g.wheelY, g.wheelR, wheelRotation, c.wheel, glowWheels, spokeCount, spokeWidth, spokeColor, knobby);
 
diff --git a/game/rendering/index.ts b/game/rendering/index.ts
index 77a2710..7d1763e 100644
--- a/game/rendering/index.ts
+++ b/game/rendering/index.ts
@@ -2,3 +2,4 @@ export { drawBackground, drawHouse, drawTreeSilhouette, drawDeer, drawWalkingPer
 export { drawPlayer, drawSkinPreview } from "./PlayerRenderer";
 export { drawObstacle } from "./ObstacleRenderer";
 export { drawFloatingText } from "./FloatingTextRenderer";
+export { drawCrashBike, drawCrashRider } from "./CrashRenderer";
diff --git a/game/types.ts b/game/types.ts
index 6055596..22ef1b5 100644
--- a/game/types.ts
+++ b/game/types.ts
@@ -1,9 +1,36 @@
 export enum GameState {
   IDLE = "IDLE",
   RUNNING = "RUNNING",
+  CRASHING = "CRASHING",
   GAME_OVER = "GAME_OVER",
 }
 
+export interface CrashState {
+  elapsed: number;
+  duration: number;
+
+  shakeIntensity: number;
+  shakeOffsetX: number;
+  shakeOffsetY: number;
+
+  riderX: number;
+  riderY: number;
+  riderVX: number;
+  riderVY: number;
+  riderAngle: number;
+  riderAngularVel: number;
+  riderBounceCount: number;
+
+  bikeX: number;
+  bikeY: number;
+  bikeVX: number;
+  bikeVY: number;
+  bikeAngle: number;
+  bikeAngularVel: number;
+  bikeBounceCount: number;
+  bikeWheelRotation: number;
+}
+
 export enum ObstacleType {
   ROCK = "ROCK",
   SMALL_TREE = "SMALL_TREE",
